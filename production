[Heroku CLI](heroku-cli) plugins are Node.js npm packages that export two objects: `topic` and `commands`. Users install them with `heroku plugins:install PLUGINNAME`, where `PLUGINNAME` is an npm package on [npmjs.com](https://npmjs.com). Plugin developers can also link them into the CLI with `heroku plugins:link`, as described below.

For more information on the Heroku CLI, check out [the project on GitHub](https://github.com/heroku/cli).

On Windows and OS X, the plugins will be run with a current version of node (usually the latest) no matter what version of node is installed on the machine (if any). There is no need to support old versions of node. If you are using Linux debs or rpms, the CLI uses the system's node.

We build our plugins in [standard JS style](https://standardjs.com) with the [flow.js](https://flow.org) type checker. Core plugins must use these tools, and we'll guide you to use them below.

We will walk you through developing a [simple hello world plugin](https://github.com/heroku/heroku-cli-hello-world). For a fuller example, check out the [heroku-git plugin](https://github.com/heroku/heroku-git).

Creating the plugin
--------------------

Install the plugin generator plugin and generate a new plugin called `heroku-cli-hello-world`. This will create a new directory called `heroku-cli-hello-world`. The "heroku-cli-" prefix is simply a convention.

```term
$ heroku plugins:install heroku-cli-plugin-generator
Installing plugin heroku-cli-plugin-generator... done
$ heroku plugins:generate heroku-cli-hello-world
Building plugin...
...
Plugin generated. Link with heroku plugins:link heroku-cli-hello-world
```

Installing the plugin
---------------------

While plugins on npmjs.com can be installed with `heroku plugins:install`, when developing plugins locally you will want to use `heroku plugins:link`. This will validate the plugin, then link it in `~/.local/share/heroku/plugins/linked.json`.

To setup this plugin locally, go to the root of your plugin directory and link the plugin:

```term
$ cd heroku-cli-hello-world
$ heroku plugins:link
Running prepare script for heroku-cli-hello-world... done
```

The initial plug-in that `heroku-cli-plugin-generator` creates has basic Hello World functionality! Try it out.

```term
$ heroku hello:world
hello world!
$ heroku hello:world --name jeff
hello jeff!
$ heroku help hello
heroku hello commands: (get help with heroku help hello:COMMAND)
 hello:world  say hi

$ heroku help hello:world
Usage: heroku hello:world [flags]

say hi

Flags:
 --name  name to say hello to
```

Now we'll show how to customize this skeleton for your own functionality.

Plugin Structure
---------------------

How does this plugin work? Let's look at the files.

```term
$ tree -I 'node_modules|flow-typed'
.
├── appveyor.yml
├── circle.yml
├── lib
│   ├── commands
│   │   └── hello.js
│   └── index.js
├── package.json
├── src
│   ├── commands
│   │   ├── hello.js
│   │   └── hello.test.js
│   └── index.js
└── yarn.lock
```

Important files:

* `package.json` describing the package's dependencies and metadata
* `appveyor.yml` [Appveyor](https://www.appveyor.com/) config (for windows CI)
* `circle.yml` [CircleCI](https://circleci.com/) config (for linux CI)
* `lib/*` babel-generated files that will go into npm tarball
* `src/*` code files checked into the repo that will not be in npm tarball
* `src/index.js` main entry point
* `src/commands/hello.js` example command
* `src/commands/hello.test.js` example command test

### package.json

This is some metadata for the package:

```json
{
  "name": "heroku-cli-hello-world",
  "version": "0.0.0",
  "files": [
    "lib"
  ],
  "keywords": [
    "heroku-plugin"
  ],
  "license": "ISC",
  "main": "lib/index.js",
  "scripts": {
    "build": "babel src -d lib --ignore '*.test.js'",
    "clean": "rimraf lib",
    "prepare": "npm run clean && npm run build",
    "test": "jest && flow && eslint .",
    "release": "np"
  },
  "dependencies": { ... },
  "devDependencies": { ... }
}
```

Make sure you update your license to whatever you like and include the associated legal language in a LICENSE.txt or similar. Our default is [ISC](https://opensource.org/licenses/ISC).

Including the keyword `heroku-plugin` in `package.json` will later help us find all plugins in the wild.

### src/index.js

The main entry point for the command has the `topic` and `commands` objects that we mentioned at the beginning of this document.

```js
import fs from 'fs-extra'
import path from 'path'

export const topic = {
  name: 'hello',
  description: 'says hello (example plugin)'
}

let dir = path.join(__dirname, 'commands')
export const commands = fs.readdirSync(dir)
  .filter(f => path.extname(f) === '.js')
  .map(f => require('./commands/' + f).default)
```

You typically won't need to edit this file other than to edit your topic's name and description. As you can see, the last four lines automatically look for exports named `default` in JS files in the `src/commands` directory.

### src/commands/hello.js

Let's look at our command, then: the `world` command in the `hello` topic.

```js
import {Command, flags} from 'cli-engine-heroku'

export default class HelloCommand extends Command {
  static topic = 'hello'
  static command = 'world'
  static description = 'say hi'
  static flags = {
    name: flags.string({description: 'name to say hello to'})
  }

  async run () {
    let name = this.flags.name || 'world'
    this.out.log(`hello ${name}!`)
  }
}
```

The CLI uses the `topic` and `command` properties to make this command execute under `heroku hello:world`. The `run` function contains the implementation. It must export a promise to be completed when the command is complete (`async` functions do this by default so long as you `await` on all promises).

Editing the plugin
------------------

The CLI will detect any changes to the plugin and automatically rebuild it. Change `this.out.log()` to say something else and run it again:

```term
$ heroku hello:world
goodbye, world!
```

Command line flags
------------------------

One way to get input from the user for a command is to declare a flag. We already have a string flag `name`, let's add a `json` flag to output JSON:

```js
import {Command, flags} from 'cli-engine-heroku'

export default class HelloCommand extends Command {
  static topic = 'hello'
  static command = 'world'
  static description = 'say hi'
  static flags = {
    name: flags.string({description: 'name to say hello to'}),
    json: flags.boolean({char: 'j', description: 'output in json format'})
  }

  async run () {
    let name = this.flags.name || 'world'
    if (this.flags.json) {
      this.out.styledJSON({hello: name})
    } else {
      this.out.log(`hello ${name}!`)
    }
  }
}
```

Now run it:

```term
$ heroku hello:world --name jeff
hello jeff!
$ heroku hello:world -j --name jeff
{
  "hello": "jeff"
}
```

You can also check to see if the flag is set up correctly by using help:

```term
$ heroku help hello:world
Usage: heroku hello:world [flags]

say hi

Flags:
 -j, --json output in json format
 --name     name to say hello to
```

As of this writing, we support six kinds of flags.

* `boolean`
* `number`
* `string`
* `app` (a Heroku app)
* `remote`(a Heroku git remote)
* `team` (a Heroku team)

An additional `org` flag is in the process of being deprecated in favor of `team`.

See more details in the code, for both the [three generic flags](https://github.com/heroku/cli-engine-command/blob/master/src/flags/index.js) and the [three Heroku-specific flags](https://github.com/heroku/cli-engine-heroku/blob/master/src/flags/index.js).

Command line arguments
----------------------------

To declare an argument instead of a flag (such as `heroku hello:world NAME` instead of `heroku hello:world --name NAME`):

```js
import {Command, flags} from 'cli-engine-heroku'

export default class HelloCommand extends Command {
  static topic = 'hello'
  static command = 'world'
  static description = 'say hi'
  static args = [
    {name: 'NAME', optional: true}
  ]

  async run () {
    // alternatively: this.argv[1]
    let name = this.args.name || 'world'
    this.out.log(`hello ${name}!`)
  }
}
```

If you want to accept a variable amount of arguments, (for instance, in [heroku run](https://github.com/heroku/heroku-run/blob/master/commands/run.js)) set `variableArgs` to true. This disables argument validation but gives full flexibility in accepting arguments.

Warnings and Errors
--------

Warnings are used to notify the user something is wrong without exiting. Errors are used to show something is wrong **and** exit:

```js
this.out.warn('this is a warning message!')
this.out.error('this is an error message!')
this.out.error('exit with code 10', 10)
this.out.error('show error but do not exit', null)
```

The `out` object supports many as-yet-undocumented useful features. [Check out the code](https://github.com/heroku/cli-engine-command/blob/master/src/output/index.js) for more.

Using the Heroku API
--------------------

To use the Heroku API, we'll add a new command to this plugin to get information about an app. Create this file at `src/commands/app.js`:

```js
import {Command, flags} from 'cli-engine-heroku'

export default class AppCommand extends Command {
  static topic = 'hello'
  static command = 'app'
  static description = 'say hi to an app'
  static flags = {
    remote: flags.remote(),
    app: flags.app({required: true})
  }

  async run () {
    let app = await this.heroku.get(`/apps/${this.flags.app}`)
    console.dir(app)
  }
}
```

And run the command with `heroku hello:app --app myapp`. Note that you must `await `on the promise that `this.heroku.get` returns as it is run asynchronously. Read up on async/await for more information on how this works.  The Heroku API client is an instance of [http-call](https://github.com/heroku/http-call).

Aliasing
---------

The CLI allows you to alias commands:

```js
import {Command, flags} from 'cli-engine-heroku'

export default class HelloCommand extends Command {
  static topic = 'hello'
  static command = 'world'
  static aliases = ['my-alias']

  async run () { ... }
}
```

Now you can use `heroku my-alias` to run the same command.

Debugging tips
--------------

Use `console.dir()` to pretty-print an object.

Run a command with `HEROKU_DEBUG=1` to print debugging statements. `HEROKU_DEBUG_HEADERS=1` to also get the headers. Use `DEBUG=*` for lots of internal debug output.

Inspect `~/.heroku/error.log` for extra error output.

All command options
-------------------

Here is an example command with all available command options.

```js
import {Command, flags} from 'cli-engine-heroku'

export default class KitchenSinkCommand extends Command {
  static topic = 'kitchen'
  static command = 'sink'
  static description = 'example command with many options set' // short help when listing many commands
  // put long help and examples here
  static help = `
  Example kitchen sink plugin.

Examples:

  $ heroku kitchen:sink large-pot --temperature=110 --drain
`,
  static hidden = true     // hide in help
  static flags = {
    temperature: flags.string({
      // get this flag value with this.flags.temperature
      char: 't',            // -t
      hidden: false,        // hide flag from help
      required: true,       // require flag to be set
      description: 'temperature of faucet', // help text
    })
  }

  // set variableArgs to true if your command needs a variable amount of arguments.
  // if true, ignores anything in the args array and does no argument validation.
  variableArgs: false,

  static args = [
    {
      // get this argument with context.args.dish
      name: 'dish',   // name of argument
      optional: true, // argument not required
      hidden: true    // do not show argument in help
      description: 'arg description'
    }
  ]
}
```

## Releasing plugins

All that is needed to run `heroku plugins:install` to install a plugin is for it to be published on [npmjs.com](https://npmjs.com).

[Create an account](https://www.npmjs.com/signup) then log into it from your terminal:

```
$ npm login
Username: dickeyxxx
Password:
Email: (this IS public) npm@heroku.com
Logged in as dickeyxxx on https://registry.npmjs.org/
```

We recommend using [np](https://github.com/sindresorhus/np) to make publishing to npm easier. Install np as a development dependency with `npm install --save-dev np`, then use these script commands in your package.json:

```js
{
  "scripts": {
    "test": "jest && flow && eslint .",
    "release": "np"
  }
}
```

Now you can perform a release with `npm run release` and it will prompt for a new version, run the tests, as well as other checks to make sure a proper release is being performed.

### Release Channels

To have a beta, staging, or development channel for plugins, you can use [npm dist-tags](https://docs.npmjs.com/cli/dist-tag).

First publish a package to a dist-tag:

```
npm publish --tag beta
```

Then install the plugin with that tag:

```
heroku plugins:install myplugin@beta
```

The CLI will continue to update the plugin to any new releases on the beta channel.

## Flow

Flow is used to validate the types used in the plugin. Run `./node_modules/.bin/flow` from the root of your project to statically check that your code is using valid types. Flow is just a checker and can be removed without impacting the execution of the plugin.

It makes development of CLI plugins much easier as it can integrate with your editor to provide powerful autocompletion. See [nuclide](https://nuclide.io) for atom or [vim-flow](https://github.com/flowtype/vim-flow) for vim.

Make sure that the flow directive: `// @flow` is at the top of each file for flow to check it.

## Testing

For information on testing your plugin, see [Testing CLI Plugins](testing-cli-plugins).
